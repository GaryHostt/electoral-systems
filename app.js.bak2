// Data structures
let parties = [];
let candidates = [];
let votes = {};
let rankings = {}; // Store ranking preferences for IRV/STV

// Configuration
function getSeatsCount() {
    const raceType = document.querySelector('input[name="raceType"]:checked')?.value || 'single';
    return raceType === 'single' ? 1 : 10;
}

// Utility function to format numbers with commas
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Function to parse formatted number back to integer
function parseFormattedNumber(str) {
    return parseInt(str.replace(/,/g, '')) || 0;
}

// Function to format input fields with commas
function formatNumberInput(event) {
    const input = event.target;
    const value = input.value.replace(/,/g, '');
    if (value && !isNaN(value)) {
        input.value = formatNumber(parseInt(value));
    }
}

// Function to draw a pie chart
function drawPieChart(canvasId, data, title) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 40;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate total
    const total = data.reduce((sum, item) => sum + item.value, 0);
    
    if (total === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data', centerX, centerY);
        return;
    }
    
    // Draw pie slices
    let currentAngle = -Math.PI / 2; // Start at top
    
    data.forEach(item => {
        const sliceAngle = (item.value / total) * 2 * Math.PI;
        
        // Draw slice
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
        ctx.closePath();
        ctx.fillStyle = item.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw label if slice is large enough
        if (sliceAngle > 0.1) {
            const labelAngle = currentAngle + sliceAngle / 2;
            const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
            const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
            
            const percentage = ((item.value / total) * 100).toFixed(1);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(percentage + '%', labelX, labelY);
            ctx.fillText(percentage + '%', labelX, labelY);
        }
        
        currentAngle += sliceAngle;
    });
    
    // Draw title
    ctx.fillStyle = '#333';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(title, centerX, 25);
    
    // Draw legend
    const legendX = 10;
    let legendY = canvas.height - (data.length * 25) - 10;
    
    data.forEach(item => {
        // Color box
        ctx.fillStyle = item.color;
        ctx.fillRect(legendX, legendY, 20, 20);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(legendX, legendY, 20, 20);
        
        // Label
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(item.label, legendX + 25, legendY + 14);
        
        legendY += 25;
    });
}

// Function to draw comparison bar chart (votes vs seats)
function drawComparisonBarChart(canvasId, data, title) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw title
    ctx.fillStyle = '#333';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(title, width / 2, 25);
    
    if (data.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '16px sans-serif';
        ctx.fillText('No data', width / 2, height / 2);
        return;
    }
    
    // Layout
    const topMargin = 50;
    const bottomMargin = 80;
    const leftMargin = 60;
    const rightMargin = 20;
    const chartHeight = height - topMargin - bottomMargin;
    const barHeight = Math.min(30, chartHeight / (data.length * 2.5));
    const barSpacing = barHeight * 0.3;
    const groupSpacing = barHeight * 1.5;
    
    // Find max percentage for scaling
    const maxPct = Math.max(...data.map(d => Math.max(d.votePct, d.seatPct)));
    const scale = (width - leftMargin - rightMargin) / Math.max(maxPct, 100);
    
    // Draw axes
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, topMargin + chartHeight);
    ctx.lineTo(width - rightMargin, topMargin + chartHeight);
    ctx.stroke();
    
    // Draw percentage gridlines
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 100; i += 20) {
        const x = leftMargin + (i * scale);
        ctx.beginPath();
        ctx.moveTo(x, topMargin);
        ctx.lineTo(x, topMargin + chartHeight);
        ctx.stroke();
        
        // Label
        ctx.fillStyle = '#666';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(i + '%', x, topMargin + chartHeight + 15);
    }
    
    // Draw bars
    let y = topMargin + 20;
    
    data.forEach((item, index) => {
        // Party label
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(item.label, leftMargin - 5, y + barHeight);
        
        // Vote bar
        const voteWidth = item.votePct * scale;
        ctx.fillStyle = item.color;
        ctx.fillRect(leftMargin, y, voteWidth, barHeight);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(leftMargin, y, voteWidth, barHeight);
        
        // Vote label
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Votes: ${item.votePct.toFixed(1)}%`, leftMargin + voteWidth + 5, y + barHeight / 2 + 4);
        
        y += barHeight + barSpacing;
        
        // Seat bar (lighter shade)
        const seatWidth = item.seatPct * scale;
        const lighterColor = adjustColorBrightness(item.color, 40);
        ctx.fillStyle = lighterColor;
        ctx.fillRect(leftMargin, y, seatWidth, barHeight);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(leftMargin, y, seatWidth, barHeight);
        
        // Seat label
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.fillText(`Seats: ${item.seatPct.toFixed(1)}%`, leftMargin + seatWidth + 5, y + barHeight / 2 + 4);
        
        y += barHeight + groupSpacing;
    });
    
    // Legend
    const legendY = height - 50;
    ctx.fillStyle = item => item.color;
    ctx.fillRect(leftMargin, legendY, 20, 15);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(leftMargin, legendY, 20, 15);
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Vote Share', leftMargin + 25, legendY + 11);
    
    const lighterDemo = adjustColorBrightness('#667eea', 40);
    ctx.fillStyle = lighterDemo;
    ctx.fillRect(leftMargin + 120, legendY, 20, 15);
    ctx.strokeRect(leftMargin + 120, legendY, 20, 15);
    ctx.fillStyle = '#333';
    ctx.fillText('Seat Share', leftMargin + 145, legendY + 11);
}

// Helper function to adjust color brightness
function adjustColorBrightness(color, amount) {
    let usePound = false;
    if (color[0] === "#") {
        color = color.slice(1);
        usePound = true;
    }
    
    const num = parseInt(color, 16);
    let r = (num >> 16) + amount;
    let g = ((num >> 8) & 0x00FF) + amount;
    let b = (num & 0x0000FF) + amount;
    
    r = Math.max(Math.min(255, r), 0);
    g = Math.max(Math.min(255, g), 0);
    b = Math.max(Math.min(255, b), 0);
    
    return (usePound ? "#" : "") + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
}

// System descriptions
const systemDescriptions = {
    fptp: "First-Past-the-Post: The candidate with the most votes wins, regardless of whether they have a majority. Simple and fast, but can lead to vote splitting.",
    trs: "Two-Round System: If no candidate gets >50% in the first round, the top two candidates proceed to a runoff. Common in presidential elections.",
    irv: "Instant-Runoff Voting: Voters rank candidates. The candidate with fewest votes is eliminated and their votes redistributed until someone has a majority.",
    borda: "Borda Count: Voters rank all candidates. Points awarded based on position (1st=n-1 points, 2nd=n-2, etc.). Candidate with most points wins.",
    condorcet: "Condorcet Method: The candidate who would beat every other candidate in head-to-head competition wins. May have no winner (Condorcet paradox).",
    "party-list-closed": "Closed List PR: Voters choose a party. Seats are allocated proportionally, and parties decide which candidates fill those seats.",
    "party-list-open": "Open List PR: Voters can vote for both a party and specific candidates within that party. Seats are allocated proportionally.",
    stv: "Single Transferable Vote: Multi-winner proportional system where voters rank candidates and votes are transferred based on quotas.",
    mmp: "Mixed-Member Proportional: Combines district seats (FPTP) with proportional party list seats to ensure overall proportionality.",
    parallel: "Parallel Voting: Combines district seats and party list seats, but they're calculated independently (not compensatory).",
    block: "Block Voting: Voters can vote for multiple candidates in a multi-seat constituency. Top vote-getters win.",
    limited: "Limited Voting: Like Block Voting, but voters have fewer votes than available seats, promoting minority representation.",
    approval: "Approval Voting: Voters can approve of as many candidates as they wish. The candidate with most approvals wins."
};

// Arrow's Theorem analysis for each system
const arrowAnalysis = {
    fptp: {
        title: "First-Past-the-Post",
        nonDictatorship: "âœ… Pass - No single voter dictates outcome",
        universality: "âš ï¸ Weak - Limited to plurality, not full preference ranking",
        independence: "âŒ Fail - Spoiler effect: third candidate can change outcome between top two",
        monotonicity: "âœ… Pass - More votes for winner cannot hurt them",
        strategicVoting: "âŒ High Risk - Voters incentivized to abandon preferred candidates to avoid 'wasted votes'. Strong spoiler effect encourages strategic voting."
    },
    trs: {
        title: "Two-Round System",
        nonDictatorship: "âœ… Pass - Majority rule in final round",
        universality: "âš ï¸ Weak - Two separate votes, not ranked",
        independence: "âŒ Fail - First round results affect who makes it to runoff",
        monotonicity: "âœ… Pass - Generally monotonic",
        strategicVoting: "âš ï¸ Moderate Risk - Voters may strategically vote in first round to influence runoff matchups. Less problematic than FPTP."
    },
    irv: {
        title: "Instant-Runoff Voting",
        nonDictatorship: "âœ… Pass - No dictator",
        universality: "âœ… Pass - Full ranking of preferences",
        independence: "âŒ Fail - Adding/removing candidates can change winner (non-monotonicity paradox)",
        monotonicity: "âŒ Fail - Ranking a candidate higher can hurt them!",
        strategicVoting: "âš ï¸ Moderate Risk - Complex strategic scenarios exist. Voters might benefit from ranking compromise candidate higher than true preference. Less vulnerable than FPTP."
    },
    borda: {
        title: "Borda Count",
        nonDictatorship: "âœ… Pass - All voters contribute points equally",
        universality: "âœ… Pass - Full ranking required",
        independence: "âŒ Fail - Adding irrelevant candidate changes point distribution",
        monotonicity: "âœ… Pass - More points always helps",
        strategicVoting: "âŒ High Risk - Vulnerable to 'burying': voters can rank strong opponents last to maximize point differential. Strategic exaggeration of preferences is highly effective."
    },
    condorcet: {
        title: "Condorcet Method",
        nonDictatorship: "âœ… Pass - Majority pairwise preference",
        universality: "âœ… Pass - Full ranking required",
        independence: "âœ… Strong - Pairwise comparisons isolate alternatives",
        monotonicity: "âœ… Pass - More votes in pairwise matchups help",
        strategicVoting: "âš ï¸ Low-Moderate Risk - Paradox cases create vulnerabilities. Voters may strategically rank to create/break cycles. When Condorcet winner exists, harder to manipulate."
    },
    "party-list-closed": {
        title: "Closed List PR",
        nonDictatorship: "âœ… Pass - Proportional representation",
        universality: "âš ï¸ Weak - Single party choice, no candidate preference",
        independence: "âœ… Pass - Party performance independent",
        monotonicity: "âœ… Pass - More votes = more seats",
        strategicVoting: "âœ… Low Risk - Proportional systems reduce wasted votes and strategic incentives. Voters can honestly support preferred party."
    },
    "party-list-open": {
        title: "Open List PR",
        nonDictatorship: "âœ… Pass - Proportional with voter input on candidates",
        universality: "âš ï¸ Moderate - Party choice + optional candidate preference",
        independence: "âœ… Pass - Generally independent",
        monotonicity: "âœ… Pass - More votes help party and candidate",
        strategicVoting: "âœ… Low Risk - Similar to closed list. Candidate preference adds complexity but maintains proportionality benefits."
    },
    stv: {
        title: "Single Transferable Vote",
        nonDictatorship: "âœ… Pass - No dictator",
        universality: "âœ… Pass - Full ranking",
        independence: "âŒ Fail - Vote transfers create dependencies",
        monotonicity: "âŒ Fail - Paradoxes exist in multi-winner context",
        strategicVoting: "âš ï¸ Low-Moderate Risk - Complex system makes strategic voting difficult to execute. Proportional nature reduces incentives. Some scenarios allow strategic candidate ranking."
    },
    mmp: {
        title: "Mixed-Member Proportional",
        nonDictatorship: "âœ… Pass - Compensatory proportional tier",
        universality: "âš ï¸ Moderate - Two separate votes (district + party)",
        independence: "âš ï¸ Moderate - Two tiers interact",
        monotonicity: "âœ… Pass - Generally monotonic",
        strategicVoting: "âš ï¸ Moderate Risk - Sophisticated voters may split tickets strategically. Small parties may benefit from strategic district voting. Overhang seats create edge cases."
    },
    parallel: {
        title: "Parallel Voting",
        nonDictatorship: "âœ… Pass - No dictator",
        universality: "âš ï¸ Moderate - Two separate votes",
        independence: "âš ï¸ Moderate - Tiers are independent but both matter",
        monotonicity: "âœ… Pass - Generally monotonic",
        strategicVoting: "âš ï¸ Moderate Risk - District tier vulnerable to FPTP problems. List tier maintains proportionality. Voters face split strategic calculus."
    },
    block: {
        title: "Block Voting",
        nonDictatorship: "âœ… Pass - No dictator",
        universality: "âš ï¸ Weak - Multiple plurality votes",
        independence: "âŒ Fail - Strong party-slate effects",
        monotonicity: "âœ… Pass - More votes help",
        strategicVoting: "âŒ High Risk - Majoritarian system. Coordinated majority can sweep all seats. Minority voters wasted. Strong incentive for bloc voting and party slates."
    },
    limited: {
        title: "Limited Voting",
        nonDictatorship: "âœ… Pass - No dictator",
        universality: "âš ï¸ Weak - Limited plurality votes",
        independence: "âš ï¸ Moderate - Vote limitation reduces party dominance",
        monotonicity: "âœ… Pass - More votes help",
        strategicVoting: "âš ï¸ Moderate Risk - Vote limitation forces strategic prioritization. Voters must decide which candidates to support. Less extreme than Block Voting."
    },
    approval: {
        title: "Approval Voting",
        nonDictatorship: "âœ… Pass - Equal weight approvals",
        universality: "âš ï¸ Weak - No ranking, just approval threshold",
        independence: "âš ï¸ Moderate - Approval threshold is strategic",
        monotonicity: "âœ… Pass - More approvals always help",
        strategicVoting: "âš ï¸ Moderate Risk - Voters must decide approval threshold strategically. Approving compromise candidates may hurt preferred candidate. Simpler than ranked systems but not strategy-proof."
    }
};

// Initialize - wrap in DOMContentLoaded to ensure DOM is ready

// Initialize - wrap in DOMContentLoaded to ensure DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('electoralSystem').addEventListener('change', onSystemChange);
    
    // Setup color picker
    setupColorPicker();
    
    // Initial state
    onSystemChange();
});

function setupColorPicker() {
    const presets = document.querySelectorAll('.color-preset:not(.custom-color)');
    const colorPicker = document.getElementById('partyColorPicker');
    const hiddenColorInput = document.getElementById('partyColor');
    
    // Select default color (blue)
    presets[1].classList.add('selected');
    hiddenColorInput.value = '#3498db';
    
    // Handle preset clicks
    presets.forEach(preset => {
        preset.addEventListener('click', function() {
            presets.forEach(p => p.classList.remove('selected'));
            this.classList.add('selected');
            const color = this.getAttribute('data-color');
            hiddenColorInput.value = color;
            colorPicker.value = color;
        });
    });
    
    // Handle custom color picker
    colorPicker.addEventListener('change', function() {
        presets.forEach(p => p.classList.remove('selected'));
        document.querySelector('.custom-color').classList.add('selected');
        hiddenColorInput.value = this.value;
    });
}

function onSystemChange() {
    const system = document.getElementById('electoralSystem').value;
    
    if (!system) {
        // No system selected - hide all sections
        document.getElementById('partiesSection').style.display = 'none';
        document.getElementById('candidatesSection').style.display = 'none';
        document.getElementById('votingSection').style.display = 'none';
        document.getElementById('systemDescription').innerHTML = '<p style="color: #999; font-style: italic;">Select an electoral system to begin</p>';
        return;
    }
    
    // Update system description
    document.getElementById('systemDescription').innerHTML = `<p>${systemDescriptions[system]}</p>`;
    
    // Systems that use a party vote (and thus need electoral threshold)
    const systemsWithPartyVote = ['party-list-closed', 'party-list-open', 'mmp', 'parallel'];
    
    // Systems that use proportional allocation methods
    const systemsWithAllocationMethod = ['party-list-closed', 'party-list-open', 'mmp', 'parallel'];
    
    // Show/hide electoral threshold input
    const thresholdContainer = document.getElementById('electoralThresholdContainer');
    if (systemsWithPartyVote.includes(system)) {
        thresholdContainer.style.display = 'block';
    } else {
        thresholdContainer.style.display = 'none';
    }
    
    // Show/hide allocation method selector
    const allocationContainer = document.getElementById('allocationMethodContainer');
    if (systemsWithAllocationMethod.includes(system)) {
        allocationContainer.style.display = 'block';
    } else {
        allocationContainer.style.display = 'none';
    }
    
    // Systems that need BOTH parties and candidates
    const needsBothPartiesAndCandidates = [
        'party-list-open', 
        'mmp', 
        'parallel'
    ];
    
    // Systems that need ONLY parties (no individual candidates)
    const needsOnlyParties = [
        'party-list-closed'
    ];
    
    // Systems that are candidate-focused (parties are just for organization/color)
    const candidateFocused = [
        'fptp',
        'trs', 
        'irv',
        'borda',
        'condorcet',
        'stv',
        'block',
        'limited',
        'approval'
    ];
    
    // Show/hide sections based on system requirements
    const partiesSection = document.getElementById('partiesSection');
    const candidatesSection = document.getElementById('candidatesSection');
    const votingSection = document.getElementById('votingSection');
    
    if (needsOnlyParties.includes(system)) {
        // Only parties, no candidates
        partiesSection.style.display = 'block';
        candidatesSection.style.display = 'none';
        votingSection.style.display = 'block';
        updateSectionNumbers(2, null, 3);
    } else if (needsBothPartiesAndCandidates.includes(system)) {
        // Both parties and candidates
        partiesSection.style.display = 'block';
        candidatesSection.style.display = 'block';
        votingSection.style.display = 'block';
        updateSectionNumbers(2, 3, 4);
    } else if (candidateFocused.includes(system)) {
        // Candidates only (parties just for grouping/colors)
        partiesSection.style.display = 'block';
        candidatesSection.style.display = 'block';
        votingSection.style.display = 'block';
        updateSectionNumbers(2, 3, 4);
    }
    
    updateVotingInputs();
}

function updateSectionNumbers(partiesNum, candidatesNum, votingNum) {
    // Update section numbers dynamically
    const partiesNumberSpan = document.querySelector('#partiesSection .section-number');
    const candidatesNumberSpan = document.querySelector('#candidatesSection .section-number');
    const votingNumberSpan = document.querySelector('#votingSection .section-number');
    
    if (partiesNumberSpan && partiesNum) partiesNumberSpan.textContent = partiesNum;
    if (candidatesNumberSpan && candidatesNum) candidatesNumberSpan.textContent = candidatesNum;
    if (votingNumberSpan && votingNum) votingNumberSpan.textContent = votingNum;
}

function updateSystemDescription() {
    onSystemChange();
}

function updateRaceType() {
    const raceType = document.querySelector('input[name="raceType"]:checked').value;
    const description = document.getElementById('raceTypeDescription');
    
    if (raceType === 'single') {
        description.textContent = 'Single race: Simulate one electoral district or seat (e.g., one House district).';
    } else {
        description.textContent = 'Entire legislature: Simulate a full parliament or congress with 10 seats distributed proportionally.';
    }
    
    // Update voting inputs to reflect the change
    updateVotingInputs();
}

function addParty() {
    const nameInput = document.getElementById('partyName');
    const colorInput = document.getElementById('partyColor');
    const name = nameInput.value.trim();
    
    if (!name) {
        alert('Please enter a party name');
        return;
    }
    
    const party = {
        id: Date.now(),
        name: name,
        color: colorInput.value
    };
    
    parties.push(party);
    nameInput.value = '';
    
    // Reset color selection to default (blue)
    const presets = document.querySelectorAll('.color-preset:not(.custom-color)');
    presets.forEach(p => p.classList.remove('selected'));
    presets[1].classList.add('selected');
    colorInput.value = '#3498db';
    document.getElementById('partyColorPicker').value = '#3498db';
    
    updatePartiesList();
    updateCandidatePartySelect();
    updateVotingInputs();
}

function removeParty(id) {
    parties = parties.filter(p => p.id !== id);
    candidates = candidates.filter(c => c.partyId !== id);
    updatePartiesList();
    updateCandidatesList();
    updateCandidatePartySelect();
    updateVotingInputs();
}

function updatePartiesList() {
    const list = document.getElementById('partiesList');
    if (parties.length === 0) {
        list.innerHTML = '<div class="empty-state">No parties added yet</div>';
        return;
    }
    
    list.innerHTML = parties.map(party => `
        <div class="item">
            <div class="item-info">
                <div class="party-color" style="background-color: ${party.color}"></div>
                <strong>${party.name}</strong>
            </div>
            <button class="btn-remove" onclick="removeParty(${party.id})">Remove</button>
        </div>
    `).join('');
}

function updateCandidatePartySelect() {
    const select = document.getElementById('candidateParty');
    select.innerHTML = '<option value="">Select Party</option>' + 
        parties.map(party => `<option value="${party.id}">${party.name}</option>`).join('');
}

function addCandidate() {
    const nameInput = document.getElementById('candidateName');
    const partySelect = document.getElementById('candidateParty');
    const name = nameInput.value.trim();
    const partyId = parseInt(partySelect.value);
    
    if (!name) {
        alert('Please enter a candidate name');
        return;
    }
    
    if (!partyId) {
        alert('Please select a party');
        return;
    }
    
    const candidate = {
        id: Date.now(),
        name: name,
        partyId: partyId
    };
    
    candidates.push(candidate);
    nameInput.value = '';
    partySelect.value = '';
    
    updateCandidatesList();
    updateVotingInputs();
}

function removeCandidate(id) {
    candidates = candidates.filter(c => c.id !== id);
    updateCandidatesList();
    updateVotingInputs();
}

function updateCandidatesList() {
    const list = document.getElementById('candidatesList');
    if (candidates.length === 0) {
        list.innerHTML = '<div class="empty-state">No candidates added yet</div>';
        return;
    }
    
    list.innerHTML = candidates.map(candidate => {
        const party = parties.find(p => p.id === candidate.partyId);
        return `
            <div class="item">
                <div class="item-info">
                    <div class="party-color" style="background-color: ${party.color}"></div>
                    <strong>${candidate.name}</strong>
                    <span style="color: #666;">(${party.name})</span>
                </div>
                <button class="btn-remove" onclick="removeCandidate(${candidate.id})">Remove</button>
            </div>
        `;
    }).join('');
}

function autoGenerateCandidates() {
    if (parties.length === 0) {
        alert('Please add parties first before auto-generating candidates');
        return;
    }
    
    let added = 0;
    parties.forEach((party, index) => {
        // Check if this party already has a candidate
        const hasCandidate = candidates.some(c => c.partyId === party.id);
        if (!hasCandidate) {
            const candidate = {
                id: Date.now() + index,
                name: `${party.name} Candidate`,
                partyId: party.id
            };
            candidates.push(candidate);
            added++;
        }
    });
    
    if (added > 0) {
        updateCandidatesList();
        updateVotingInputs();
        alert(`Added ${added} candidate(s)`);
    } else {
        alert('All parties already have at least one candidate');
    }
}

function updateVotingInputs() {
    const system = document.getElementById('electoralSystem').value;
    const container = document.getElementById('votingInputs');
    
    if (parties.length === 0 && candidates.length === 0) {
        container.innerHTML = '<div class="empty-state">Add parties and candidates first</div>';
        return;
    }
    
    let html = '';
    
    // Check if this is a ranking system
    const isRankingSystem = system === 'irv' || system === 'stv' || system === 'borda' || system === 'condorcet';
    
    // Systems that use a party vote:
    // - Party-List PR (Closed and Open List)
    // - Mixed-Member Proportional (MMP/AMS)
    // - Parallel Voting (MMM)
    const systemsWithPartyVote = ['party-list-closed', 'party-list-open', 'mmp', 'parallel'];
    
    // Systems that do NOT use a party vote:
    // - FPTP, TRS, IRV
    // - STV (candidate-focused, no distinct party vote)
    // - Block Voting, Limited Voting, Approval Voting
    
    if (systemsWithPartyVote.includes(system)) {
        html += '<div class="voting-input-section"><h4>Party Votes</h4>';
        
        // Add explanation for mixed systems
        if (system === 'mmp' || system === 'parallel') {
            html += '<p style="margin-bottom: 10px; color: #666; font-style: italic;">This is the party list vote (second vote) used for proportional seat allocation.</p>';
        }
        
        parties.forEach(party => {
            html += `
                <div class="vote-input-row">
                    <label>
                        <span class="party-color" style="display: inline-block; width: 15px; height: 15px; background-color: ${party.color}; border-radius: 50%; margin-right: 5px;"></span>
                        ${party.name}
                    </label>
                    <input type="text" min="0" value="0" id="party-${party.id}" class="number-input" />
                </div>
            `;
        });
        html += '</div>';
    }
    
    // For candidate-based systems
    // Show candidate votes for all systems except pure closed list
    if (system !== 'party-list-closed') {
        html += '<div class="voting-input-section"><h4>Candidate Votes</h4>';
        
        // System-specific instructions
        if (system === 'mmp' || system === 'parallel') {
            html += '<p style="margin-bottom: 10px; color: #666; font-style: italic;">This is the constituency vote (first vote) for individual candidates.</p>';
        } else if (isRankingSystem) {
            html += '<p style="margin-bottom: 10px; color: #666;">Enter first-preference vote totals here. Rankings can be configured below.</p>';
        } else if (system === 'approval') {
            html += '<p style="margin-bottom: 10px; color: #666;">Enter number of voters who approve each candidate</p>';
        } else if (system === 'party-list-open') {
            html += '<p style="margin-bottom: 10px; color: #666; font-style: italic;">Optional: Personal votes for specific candidates within their party.</p>';
        }
        
        candidates.forEach(candidate => {
            const party = parties.find(p => p.id === candidate.partyId);
            html += `
                <div class="vote-input-row">
                    <label>
                        <span class="party-color" style="display: inline-block; width: 15px; height: 15px; background-color: ${party.color}; border-radius: 50%; margin-right: 5px;"></span>
                        ${candidate.name}
                    </label>
                    <input type="text" min="0" value="0" id="candidate-${candidate.id}" class="number-input" />
                </div>
            `;
        });
        html += '</div>';
    }
    
    // Add ranking inputs for IRV and STV
    if (isRankingSystem && candidates.length > 0) {
        html += generateRankingInputs(system);
    }
    
    container.innerHTML = html;
    
    // Add event listeners for number formatting
    document.querySelectorAll('.number-input').forEach(input => {
        input.addEventListener('blur', formatNumberInput);
        input.addEventListener('focus', function() {
            this.value = this.value.replace(/,/g, '');
        });
    });
}

function generateRankingInputs(system) {
    let html = '<div class="ranking-input-container">';
    html += '<h4 style="margin-top: 0; color: #667eea;">ðŸ“Š Voter Preference Rankings</h4>';
    html += '<p style="color: #666; margin-bottom: 15px;">Configure how voters rank candidates. Each ballot shows voter preferences in order.</p>';
    
    // Create sample ballots
    const numBallots = Math.min(5, candidates.length);
    html += '<div class="ranking-grid">';
    
    for (let i = 0; i < numBallots; i++) {
        html += `
            <div class="ranking-item">
                <h5>
                    <span style="background: #667eea; color: white; width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 0.9em;">${i + 1}</span>
                    Ballot Type ${i + 1}
                </h5>
                <div class="ranking-inputs">
        `;
        
        // Add ranking dropdowns for each preference
        const maxRanks = Math.min(candidates.length, 5);
        for (let rank = 1; rank <= maxRanks; rank++) {
            html += `
                <div class="ranking-row">
                    <label>${rank}${getOrdinalSuffix(rank)} choice:</label>
                    <select id="ballot-${i}-rank-${rank}" onchange="updateRankings()">
                        <option value="">--</option>
            `;
            
            candidates.forEach(candidate => {
                const party = parties.find(p => p.id === candidate.partyId);
                html += `<option value="${candidate.id}">${candidate.name} (${party.name})</option>`;
            });
            
            html += `
                    </select>
                </div>
            `;
        }
        
        // Add vote count for this ballot type
        html += `
            <div class="ranking-row" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
                <label style="font-weight: 600;">Ballots:</label>
                <input type="text" id="ballot-${i}-count" class="number-input" value="0" style="padding: 6px;" onblur="formatNumberInput(event)" />
            </div>
        `;
        
        html += `
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    html += '<p style="margin-top: 15px; color: #666; font-size: 0.9em; font-style: italic;">ðŸ’¡ Tip: Leave a choice blank if voters don\'t rank that many candidates. "Ballots" = number of voters with this exact ranking.</p>';
    html += '</div>';
    
    return html;
}

function getOrdinalSuffix(n) {
    const s = ["th", "st", "nd", "rd"];
    const v = n % 100;
    return s[(v - 20) % 10] || s[v] || s[0];
}

function updateRankings() {
    // Store rankings for later use in calculations
    // This function is called whenever a ranking dropdown changes
}

function getVotes() {
    const votes = {
        parties: {},
        candidates: {}
    };
    
    parties.forEach(party => {
        const input = document.getElementById(`party-${party.id}`);
        if (input) {
            votes.parties[party.id] = parseFormattedNumber(input.value);
        }
    });
    
    candidates.forEach(candidate => {
        const input = document.getElementById(`candidate-${candidate.id}`);
        if (input) {
            votes.candidates[candidate.id] = parseFormattedNumber(input.value);
        }
    });
    
    return votes;
}

function calculateResults() {
    const system = document.getElementById('electoralSystem').value;
    const votes = getVotes();
    
    let results;
    
    switch(system) {
        case 'fptp':
            results = calculateFPTP(votes);
            break;
        case 'trs':
            results = calculateTRS(votes);
            break;
        case 'irv':
            results = calculateIRV(votes);
            break;
        case 'borda':
            results = calculateBorda(votes);
            break;
        case 'condorcet':
            results = calculateCondorcet(votes);
            break;
        case 'party-list-closed':
            results = calculateClosedList(votes);
            break;
        case 'party-list-open':
            results = calculateOpenList(votes);
            break;
        case 'stv':
            results = calculateSTV(votes);
            break;
        case 'mmp':
            results = calculateMMP(votes);
            break;
        case 'parallel':
            results = calculateParallel(votes);
            break;
        case 'block':
            results = calculateBlock(votes);
            break;
        case 'limited':
            results = calculateLimited(votes);
            break;
        case 'approval':
            results = calculateApproval(votes);
            break;
    }
    
    displayResults(results, system);
}

function calculateFPTP(votes) {
    const results = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount,
            percentage: 0
        };
    });
    
    const totalVotes = results.reduce((sum, r) => sum + r.votes, 0);
    results.forEach(r => {
        r.percentage = totalVotes > 0 ? (r.votes / totalVotes * 100) : 0;
    });
    
    results.sort((a, b) => b.votes - a.votes);
    
    if (results.length > 0) {
        results[0].winner = true;
    }
    
    return {
        type: 'candidate',
        results: results,
        totalVotes: totalVotes
    };
}

function calculateTRS(votes) {
    const results = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount,
            percentage: 0
        };
    });
    
    const totalVotes = results.reduce((sum, r) => sum + r.votes, 0);
    results.forEach(r => {
        r.percentage = totalVotes > 0 ? (r.votes / totalVotes * 100) : 0;
    });
    
    results.sort((a, b) => b.votes - a.votes);
    
    // Check if anyone has >50%
    if (results.length > 0 && results[0].percentage > 50) {
        results[0].winner = true;
        results[0].note = "Won in first round with majority";
    } else if (results.length >= 2) {
        results[0].note = "Would proceed to runoff";
        results[1].note = "Would proceed to runoff";
        // In simulation, highest vote getter wins runoff
        results[0].winner = true;
    }
    
    return {
        type: 'candidate',
        results: results,
        totalVotes: totalVotes
    };
}

function calculateIRV(votes) {
    // Get race type
    const raceType = document.querySelector('input[name="raceType"]:checked')?.value || 'single';
    
    // Collect ballot data from ranking inputs
    const ballots = [];
    let totalBallots = 0;
    
    // Check if we have ranking data
    let hasRankingData = false;
    for (let i = 0; i < 5; i++) {
        const countInput = document.getElementById(`ballot-${i}-count`);
        if (countInput) {
            const count = parseFormattedNumber(countInput.value);
            if (count > 0) {
                hasRankingData = true;
                const ballot = { count: count, preferences: [] };
                
                // Get preferences for this ballot
                for (let rank = 1; rank <= 5; rank++) {
                    const select = document.getElementById(`ballot-${i}-rank-${rank}`);
                    if (select && select.value) {
                        ballot.preferences.push(parseInt(select.value));
                    }
                }
                
                if (ballot.preferences.length > 0) {
                    ballots.push(ballot);
                    totalBallots += count;
                }
            }
        }
    }
    
    // If no ranking data, fall back to simple first-preference counts
    if (!hasRankingData || ballots.length === 0) {
        const results = candidates.map(candidate => {
            const voteCount = votes.candidates[candidate.id] || 0;
            const party = parties.find(p => p.id === candidate.partyId);
            return {
                name: candidate.name,
                party: party.name,
                color: party.color,
                votes: voteCount,
                percentage: 0,
                active: true
            };
        });
        
        const totalVotes = results.reduce((sum, r) => sum + r.votes, 0);
        
        // Simulate elimination rounds
        let rounds = 0;
        while (rounds < 10) {
            const activeResults = results.filter(r => r.active);
            if (activeResults.length <= 1) break;
            
            const activeTotal = activeResults.reduce((sum, r) => sum + r.votes, 0);
            
            // Check for majority
            const topCandidate = activeResults.reduce((max, r) => r.votes > max.votes ? r : max);
            if (topCandidate.votes / activeTotal > 0.5) {
                topCandidate.winner = true;
                topCandidate.note = rounds === 0 ? 'Won with first-round majority' : `Won after ${rounds} elimination round(s)`;
                break;
            }
            
            // Eliminate lowest
            const lowest = activeResults.reduce((min, r) => r.votes < min.votes ? r : min);
            lowest.active = false;
            lowest.note = `Eliminated in round ${rounds + 1}`;
            
            rounds++;
        }
        
        results.forEach(r => {
            r.percentage = totalVotes > 0 ? (r.votes / totalVotes * 100) : 0;
        });
        
        results.sort((a, b) => b.votes - a.votes);
        
        return {
            type: 'candidate',
            results: results,
            totalVotes: totalVotes,
            note: "Using first-preference votes only (no ranking data provided)"
        };
    }
    
    // Run IRV with full ranking data
    const candidateIds = candidates.map(c => c.id);
    let eliminated = new Set();
    let rounds = 0;
    const maxRounds = candidates.length - 1;
    
    while (rounds < maxRounds) {
        // Count current votes
        const voteCounts = {};
        candidateIds.forEach(id => voteCounts[id] = 0);
        
        ballots.forEach(ballot => {
            // Find first non-eliminated preference
            for (let prefId of ballot.preferences) {
                if (!eliminated.has(prefId)) {
                    voteCounts[prefId] += ballot.count;
                    break;
                }
            }
        });
        
        // Check for majority
        const activeCandidates = candidateIds.filter(id => !eliminated.has(id));
        if (activeCandidates.length === 1) {
            // Winner found
            break;
        }
        
        const activeTotal = Object.keys(voteCounts)
            .filter(id => !eliminated.has(parseInt(id)))
            .reduce((sum, id) => sum + voteCounts[id], 0);
        
        const maxVotes = Math.max(...activeCandidates.map(id => voteCounts[id]));
        if (maxVotes / activeTotal > 0.5) {
            // Majority winner
            break;
        }
        
        // Eliminate candidate with fewest votes
        const minVotes = Math.min(...activeCandidates.map(id => voteCounts[id]));
        const toEliminate = activeCandidates.find(id => voteCounts[id] === minVotes);
        eliminated.add(toEliminate);
        
        rounds++;
    }
    
    // Final count
    const finalCounts = {};
    candidateIds.forEach(id => finalCounts[id] = 0);
    
    ballots.forEach(ballot => {
        for (let prefId of ballot.preferences) {
            if (!eliminated.has(prefId)) {
                finalCounts[prefId] += ballot.count;
                break;
            }
        }
    });
    
    // Build results
    const results = candidates.map(candidate => {
        const party = parties.find(p => p.id === candidate.partyId);
        const voteCount = finalCounts[candidate.id] || 0;
        const isEliminated = eliminated.has(candidate.id);
        const isWinner = !isEliminated && voteCount === Math.max(...Object.values(finalCounts));
        
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount,
            percentage: totalBallots > 0 ? (voteCount / totalBallots * 100) : 0,
            winner: isWinner,
            note: isEliminated ? 'Eliminated' : (isWinner ? `Won after ${rounds} round(s)` : '')
        };
    });
    
    results.sort((a, b) => b.votes - a.votes);
    
    return {
        type: 'candidate',
        results: results,
        totalVotes: totalBallots,
        note: `Instant-Runoff Voting with ranked ballots (${rounds} elimination rounds)`
    };
}

function calculateClosedList(votes) {
    const totalVotes = Object.values(votes.parties).reduce((sum, v) => sum + v, 0);
    const seats = getSeatsCount();
    
    // Get electoral threshold
    const thresholdInput = document.getElementById('electoralThreshold');
    const threshold = thresholdInput ? parseFloat(thresholdInput.value) : 0;
    
    // Get allocation method
    const allocationMethod = document.getElementById('allocationMethod')?.value || 'dhondt';
    
    // Filter parties that meet the threshold
    const partyVotes = {};
    const results = parties.map(party => {
        const voteCount = votes.parties[party.id] || 0;
        const percentage = totalVotes > 0 ? (voteCount / totalVotes * 100) : 0;
        const meetsThreshold = percentage >= threshold;
        
        if (meetsThreshold && voteCount > 0) {
            partyVotes[party.id] = voteCount;
        }
        
        return {
            id: party.id,
            name: party.name,
            color: party.color,
            votes: voteCount,
            percentage: percentage,
            seats: 0,
            meetsThreshold: meetsThreshold,
            belowThreshold: !meetsThreshold && voteCount > 0
        };
    });
    
    // Allocate seats using chosen method
    let allocatedSeats;
    if (allocationMethod === 'sainte-lague') {
        allocatedSeats = allocateSeats_SainteLague(partyVotes, seats);
    } else {
        allocatedSeats = allocateSeats_DHondt(partyVotes, seats);
    }
    
    // Update results with allocated seats
    results.forEach(r => {
        r.seats = allocatedSeats[r.id] || 0;
    });
    
    results.sort((a, b) => b.seats - a.seats || b.votes - a.votes);
    
    // Calculate disproportionality
    const voteShares = {};
    const seatShares = {};
    results.forEach(r => {
        voteShares[r.id] = r.percentage;
        seatShares[r.id] = seats > 0 ? (r.seats / seats * 100) : 0;
    });
    const disproportionality = calculateLoosemoreHanby(voteShares, seatShares);
    
    return {
        type: 'party',
        results: results,
        totalVotes: totalVotes,
        totalSeats: seats,
        threshold: threshold,
        allocationMethod: allocationMethod,
        disproportionality: disproportionality
    };
}

function calculateOpenList(votes) {
    // Similar to closed list but also shows candidate preferences
    const partyResults = calculateClosedList(votes);
    
    // Add candidate information
    partyResults.candidateVotes = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount
        };
    }).sort((a, b) => b.votes - a.votes);
    
    return partyResults;
}

function calculateSTV(votes) {
    // Get race type to determine number of seats
    const raceType = document.querySelector('input[name="raceType"]:checked')?.value || 'single';
    const seats = raceType === 'single' ? 1 : 3; // 1 seat for single race, 3 for legislative
    
    // Collect ballot data from ranking inputs
    const ballots = [];
    let totalBallots = 0;
    
    // Check if we have ranking data
    let hasRankingData = false;
    for (let i = 0; i < 5; i++) {
        const countInput = document.getElementById(`ballot-${i}-count`);
        if (countInput) {
            const count = parseFormattedNumber(countInput.value);
            if (count > 0) {
                hasRankingData = true;
                const ballot = { count: count, preferences: [] };
                
                // Get preferences for this ballot
                for (let rank = 1; rank <= 5; rank++) {
                    const select = document.getElementById(`ballot-${i}-rank-${rank}`);
                    if (select && select.value) {
                        ballot.preferences.push(parseInt(select.value));
                    }
                }
                
                if (ballot.preferences.length > 0) {
                    ballots.push(ballot);
                    totalBallots += count;
                }
            }
        }
    }
    
    // If no ranking data, fall back to simple calculation
    if (!hasRankingData || ballots.length === 0) {
        const results = candidates.map(candidate => {
            const voteCount = votes.candidates[candidate.id] || 0;
            const party = parties.find(p => p.id === candidate.partyId);
            return {
                name: candidate.name,
                party: party.name,
                color: party.color,
                votes: voteCount,
                percentage: 0,
                elected: false
            };
        });
        
        const totalVotes = results.reduce((sum, r) => sum + r.votes, 0);
        const quota = Math.floor(totalVotes / (seats + 1)) + 1;
        
        results.forEach(r => {
            r.percentage = totalVotes > 0 ? (r.votes / totalVotes * 100) : 0;
            if (r.votes >= quota) {
                r.elected = true;
            }
        });
        
        results.sort((a, b) => b.votes - a.votes);
        
        // Elect top candidates up to seats available
        let seatsAllocated = 0;
        results.forEach(r => {
            if (seatsAllocated < seats) {
                r.elected = true;
                seatsAllocated++;
            }
        });
        
        return {
            type: 'multi-winner',
            results: results,
            totalVotes: totalVotes,
            seats: seats,
            quota: quota,
            note: "Using first-preference votes only (no ranking data provided)"
        };
    }
    
    // Run STV with full ranking data
    const quota = Math.floor(totalBallots / (seats + 1)) + 1;
    const candidateIds = candidates.map(c => c.id);
    let elected = [];
    let eliminated = new Set();
    
    // Run rounds until all seats filled or no more candidates
    while (elected.length < seats && eliminated.size + elected.length < candidateIds.length) {
        // Count current votes
        const voteCounts = {};
        candidateIds.forEach(id => voteCounts[id] = 0);
        
        ballots.forEach(ballot => {
            // Find first non-eliminated, non-elected preference
            for (let prefId of ballot.preferences) {
                if (!eliminated.has(prefId) && !elected.includes(prefId)) {
                    voteCounts[prefId] += ballot.count;
                    break;
                }
            }
        });
        
        // Check if anyone meets quota
        const activeCandidates = candidateIds.filter(id => !eliminated.has(id) && !elected.includes(id));
        const maxVotes = Math.max(...activeCandidates.map(id => voteCounts[id] || 0));
        
        if (maxVotes >= quota) {
            // Elect candidate with most votes
            const winner = activeCandidates.find(id => voteCounts[id] === maxVotes);
            elected.push(winner);
            // In real STV, surplus votes would transfer; simplified here
        } else {
            // Eliminate candidate with fewest votes
            const minVotes = Math.min(...activeCandidates.map(id => voteCounts[id] || 0));
            const toEliminate = activeCandidates.find(id => voteCounts[id] === minVotes);
            if (toEliminate) {
                eliminated.add(toEliminate);
            } else {
                break;
            }
        }
    }
    
    // Build results
    const results = candidates.map(candidate => {
        const party = parties.find(p => p.id === candidate.partyId);
        const isElected = elected.includes(candidate.id);
        
        // Get final vote count
        let voteCount = 0;
        ballots.forEach(ballot => {
            for (let prefId of ballot.preferences) {
                if (!eliminated.has(prefId) && !elected.includes(prefId) || prefId === candidate.id) {
                    if (prefId === candidate.id) {
                        voteCount += ballot.count;
                    }
                    break;
                }
            }
        });
        
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount,
            percentage: totalBallots > 0 ? (voteCount / totalBallots * 100) : 0,
            elected: isElected
        };
    });
    
    results.sort((a, b) => {
        if (a.elected && !b.elected) return -1;
        if (!a.elected && b.elected) return 1;
        return b.votes - a.votes;
    });
    
    return {
        type: 'multi-winner',
        results: results,
        totalVotes: totalBallots,
        seats: seats,
        quota: quota,
        note: `Single Transferable Vote with ranked ballots (Quota: ${quota} votes)`
    };
}

function calculateMMP(votes) {
    // Mixed system: half seats from districts (FPTP), half from party lists (compensatory)
    const totalSeats = getSeatsCount();
    const districtSeats = Math.floor(totalSeats / 2);
    const listSeats = totalSeats - districtSeats;
    
    // Get electoral threshold
    const thresholdInput = document.getElementById('electoralThreshold');
    const threshold = thresholdInput ? parseFloat(thresholdInput.value) : 0;
    
    // Get allocation method
    const allocationMethod = document.getElementById('allocationMethod')?.value || 'dhondt';
    
    // District seats (FPTP)
    const candidateResults = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            candidateId: candidate.id,
            name: candidate.name,
            partyId: party.id,
            party: party.name,
            color: party.color,
            votes: voteCount
        };
    });
    candidateResults.sort((a, b) => b.votes - a.votes);
    
    // Allocate district seats
    const partyDistrictSeats = {};
    parties.forEach(p => partyDistrictSeats[p.id] = 0);
    
    for (let i = 0; i < Math.min(districtSeats, candidateResults.length); i++) {
        candidateResults[i].districtSeat = true;
        partyDistrictSeats[candidateResults[i].partyId]++;
    }
    
    // Calculate proportional entitlement based on party votes
    const totalPartyVotes = Object.values(votes.parties).reduce((sum, v) => sum + v, 0);
    
    // Filter parties meeting threshold
    const eligiblePartyVotes = {};
    parties.forEach(party => {
        const voteShare = votes.parties[party.id] || 0;
        const percentage = totalPartyVotes > 0 ? (voteShare / totalPartyVotes * 100) : 0;
        if (percentage >= threshold && voteShare > 0) {
            eligiblePartyVotes[party.id] = voteShare;
        }
    });
    
    // Calculate proportional entitlement for entire parliament
    const eligibleTotalVotes = Object.values(eligiblePartyVotes).reduce((sum, v) => sum + v, 0);
    const proportionalEntitlement = {};
    
    parties.forEach(party => {
        const voteShare = eligiblePartyVotes[party.id] || 0;
        if (voteShare > 0) {
            proportionalEntitlement[party.id] = (voteShare / eligibleTotalVotes) * totalSeats;
        } else {
            proportionalEntitlement[party.id] = 0;
        }
    });
    
    // Implement overhang seats
    let overhangSeats = 0;
    const finalSeats = {};
    
    parties.forEach(party => {
        const districtWon = partyDistrictSeats[party.id] || 0;
        const entitled = proportionalEntitlement[party.id] || 0;
        
        if (districtWon > entitled) {
            // Overhang: party keeps all district seats
            finalSeats[party.id] = districtWon;
            overhangSeats += (districtWon - Math.floor(entitled));
        } else {
            // Normal: round up to entitled seats
            finalSeats[party.id] = Math.max(districtWon, Math.round(entitled));
        }
    });
    
    // If there are overhang seats, recalculate total parliament size
    let actualTotalSeats = totalSeats;
    if (overhangSeats > 0) {
        actualTotalSeats = Object.values(finalSeats).reduce((sum, s) => sum + s, 0);
        
        // Recalculate other parties' seats to maintain proportionality
        parties.forEach(party => {
            const districtWon = partyDistrictSeats[party.id] || 0;
            const entitled = proportionalEntitlement[party.id] || 0;
            
            if (districtWon <= entitled) {
                // Adjust for expanded parliament
                const newEntitlement = (eligiblePartyVotes[party.id] || 0) / eligibleTotalVotes * actualTotalSeats;
                finalSeats[party.id] = Math.max(districtWon, Math.round(newEntitlement));
            }
        });
        
        actualTotalSeats = Object.values(finalSeats).reduce((sum, s) => sum + s, 0);
    }
    
    const results = parties.map(party => {
        const partyVotes = votes.parties[party.id] || 0;
        const percentage = totalPartyVotes > 0 ? (partyVotes / totalPartyVotes * 100) : 0;
        const meetsThreshold = percentage >= threshold;
        const districtWon = partyDistrictSeats[party.id] || 0;
        const totalSeatsWon = finalSeats[party.id] || 0;
        const listSeatsWon = totalSeatsWon - districtWon;
        
        return {
            id: party.id,
            name: party.name,
            color: party.color,
            votes: partyVotes,
            percentage: percentage,
            seats: totalSeatsWon,
            districtSeats: districtWon,
            listSeats: listSeatsWon,
            meetsThreshold: meetsThreshold,
            belowThreshold: !meetsThreshold && partyVotes > 0,
            hasOverhang: districtWon > (proportionalEntitlement[party.id] || 0)
        };
    });
    
    results.sort((a, b) => b.seats - a.seats || b.votes - a.votes);
    
    // Calculate disproportionality
    const voteShares = {};
    const seatShares = {};
    results.forEach(r => {
        voteShares[r.id] = r.percentage;
        seatShares[r.id] = actualTotalSeats > 0 ? (r.seats / actualTotalSeats * 100) : 0;
    });
    const disproportionality = calculateLoosemoreHanby(voteShares, seatShares);
    
    return {
        type: 'mixed',
        results: results,
        totalVotes: totalPartyVotes,
        totalSeats: actualTotalSeats,
        plannedSeats: totalSeats,
        districtSeats: districtSeats,
        listSeats: listSeats,
        overhangSeats: overhangSeats,
        threshold: threshold,
        allocationMethod: allocationMethod,
        disproportionality: disproportionality
    };
}

function calculateParallel(votes) {
    // Similar to MMP but non-compensatory
    const totalSeats = getSeatsCount();
    const districtSeats = Math.floor(totalSeats / 2);
    const listSeats = totalSeats - districtSeats;
    
    // Get electoral threshold
    const thresholdInput = document.getElementById('electoralThreshold');
    const threshold = thresholdInput ? parseFloat(thresholdInput.value) : 0;
    
    // Get allocation method
    const allocationMethod = document.getElementById('allocationMethod')?.value || 'dhondt';
    
    // District tier (FPTP)
    const candidateResults = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            partyId: party.id,
            party: party.name,
            color: party.color,
            votes: voteCount
        };
    });
    candidateResults.sort((a, b) => b.votes - a.votes);
    
    const partyDistrictSeats = {};
    parties.forEach(p => partyDistrictSeats[p.id] = 0);
    
    for (let i = 0; i < Math.min(districtSeats, candidateResults.length); i++) {
        partyDistrictSeats[candidateResults[i].partyId]++;
    }
    
    // List tier (separate PR allocation with threshold)
    const totalPartyVotes = Object.values(votes.parties).reduce((sum, v) => sum + v, 0);
    
    // Filter parties that meet threshold
    const eligiblePartyVotes = {};
    parties.forEach(party => {
        const voteShare = votes.parties[party.id] || 0;
        const percentage = totalPartyVotes > 0 ? (voteShare / totalPartyVotes * 100) : 0;
        if (percentage >= threshold && voteShare > 0) {
            eligiblePartyVotes[party.id] = voteShare;
        }
    });
    
    // Allocate list seats using chosen method
    let partyListSeats;
    if (allocationMethod === 'sainte-lague') {
        partyListSeats = allocateSeats_SainteLague(eligiblePartyVotes, listSeats);
    } else {
        partyListSeats = allocateSeats_DHondt(eligiblePartyVotes, listSeats);
    }
    
    // Ensure all parties have seat counts initialized
    parties.forEach(p => {
        if (!partyListSeats[p.id]) partyListSeats[p.id] = 0;
    });
    
    const results = parties.map(party => {
        const partyVotes = votes.parties[party.id] || 0;
        const distSeats = partyDistrictSeats[party.id] || 0;
        const lstSeats = partyListSeats[party.id] || 0;
        const percentage = totalPartyVotes > 0 ? (partyVotes / totalPartyVotes * 100) : 0;
        const meetsThreshold = percentage >= threshold;
        
        return {
            id: party.id,
            name: party.name,
            color: party.color,
            votes: partyVotes,
            percentage: percentage,
            seats: distSeats + lstSeats,
            districtSeats: distSeats,
            listSeats: lstSeats,
            meetsThreshold: meetsThreshold,
            belowThreshold: !meetsThreshold && partyVotes > 0
        };
    });
    
    results.sort((a, b) => b.seats - a.seats || b.votes - a.votes);
    
    // Calculate disproportionality
    const voteShares = {};
    const seatShares = {};
    results.forEach(r => {
        voteShares[r.id] = r.percentage;
        seatShares[r.id] = totalSeats > 0 ? (r.seats / totalSeats * 100) : 0;
    });
    const disproportionality = calculateLoosemoreHanby(voteShares, seatShares);
    
    return {
        type: 'mixed',
        results: results,
        totalVotes: totalPartyVotes,
        totalSeats: totalSeats,
        districtSeats: districtSeats,
        listSeats: listSeats,
        note: "District and list seats calculated independently (non-compensatory)",
        threshold: threshold,
        allocationMethod: allocationMethod,
        disproportionality: disproportionality
    };
}

function calculateBlock(votes) {
    // Voters can vote for multiple candidates, top N win
    const seats = 3;
    
    const results = candidates.map(candidate => {
        const voteCount = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            votes: voteCount,
            percentage: 0,
            elected: false
        };
    });
    
    const totalVotes = results.reduce((sum, r) => sum + r.votes, 0);
    results.forEach(r => {
        r.percentage = totalVotes > 0 ? (r.votes / totalVotes * 100) : 0;
    });
    
    results.sort((a, b) => b.votes - a.votes);
    
    for (let i = 0; i < Math.min(seats, results.length); i++) {
        results[i].elected = true;
    }
    
    return {
        type: 'multi-winner',
        results: results,
        totalVotes: totalVotes,
        seats: seats
    };
}

function calculateLimited(votes) {
    // Similar to block but with limited votes per voter (simulated)
    // For simulation, same as block but with note
    const result = calculateBlock(votes);
    result.note = "Voters have fewer votes than seats available, promoting minority representation";
    return result;
}

function calculateApproval(votes) {
    // Each input represents number of approvals
    const results = candidates.map(candidate => {
        const approvals = votes.candidates[candidate.id] || 0;
        const party = parties.find(p => p.id === candidate.partyId);
        return {
            name: candidate.name,
            party: party.name,
            color: party.color,
            approvals: approvals,
            percentage: 0
        };
    });
    
    const totalApprovals = results.reduce((sum, r) => sum + r.approvals, 0);
    results.forEach(r => {
        r.percentage = totalApprovals > 0 ? (r.approvals / totalApprovals * 100) : 0;
    });
    
    results.sort((a, b) => b.approvals - a.approvals);
    
    if (results.length > 0) {
        results[0].winner = true;
    }
    
    return {
        type: 'approval',
        results: results,
        totalApprovals: totalApprovals
    };
}

function displayResults(results, system) {
    const resultsSection = document.getElementById('resultsSection');
    const resultsDiv = document.getElementById('results');
    const arrowDiv = document.getElementById('arrowAnalysis');
    const aiAnalysisSection = document.getElementById('aiAnalysisSection');
    
    resultsSection.style.display = 'block';
    aiAnalysisSection.style.display = 'block'; // Show AI analysis section
    
    // Save election data to localStorage for AI analysis
    try {
        const electionData = {
            system: systemDescriptions[system] || system,
            systemKey: system,
            results: results,
            parameters: {
                seats: parseInt(document.getElementById('raceType')?.value) || 1,
                threshold: parseFloat(document.getElementById('electoralThreshold')?.value) || 0
            },
            timestamp: new Date().toISOString()
        };
        localStorage.setItem('lastElectionResults', JSON.stringify(electionData));
        
        // Also store in global variable for immediate access
        window.lastElectionResults = electionData;
    } catch (e) {
        console.error('Error saving election data:', e);
    }
    
    let html = '';
    
    // Prepare data for pie charts
    let votesChartData = [];
    let seatsChartData = [];
    
    if (results.type === 'candidate') {
        // Add pie charts section
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="winnerChart" width="400" height="400"></canvas>';
        html += '</div>';
        
        // Display ideological spectrum
        if (typeof displayIdeologicalSpectrum === 'function' && candidates.length > 0) {
            html += displayIdeologicalSpectrum(candidates, results);
        }
        
        html += '<h3>Results by Candidate</h3>';
        results.results.forEach(r => {
            html += `
                <div class="result-item" style="border-left-color: ${r.color}">
                    <div class="result-info">
                        <div class="result-name">
                            ${r.name}
                            ${r.winner ? '<span class="winner-badge">WINNER</span>' : ''}
                        </div>
                        <div class="result-stats">
                            ${r.party} â€¢ ${formatNumber(r.votes)} votes â€¢ ${r.percentage.toFixed(1)}%
                            ${r.note ? `<br><em>${r.note}</em>` : ''}
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${r.percentage}%">
                            ${r.percentage.toFixed(1)}%
                        </div>
                    </div>
                </div>
            `;
            
            // Collect data for votes chart
            votesChartData.push({
                label: r.name,
                value: r.votes,
                color: r.color
            });
            
            // Collect data for winner chart (winner gets 1, others get 0)
            if (r.winner) {
                seatsChartData.push({
                    label: r.name + ' (Winner)',
                    value: 1,
                    color: r.color
                });
            }
        });
    } else if (results.type === 'party') {
        // Add charts section
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="comparisonChart" width="600" height="400"></canvas>';
        html += '</div>';
        
        // Show disproportionality index if available
        if (results.disproportionality !== undefined) {
            const dispColor = results.disproportionality < 5 ? '#2ecc71' : results.disproportionality < 10 ? '#f39c12' : '#e74c3c';
            const dispRating = results.disproportionality < 5 ? 'Excellent' : results.disproportionality < 10 ? 'Moderate' : 'High';
            html += `<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid ${dispColor};">
                <strong style="color: ${dispColor};">ðŸ“Š Loosemore-Hanby Disproportionality Index: ${results.disproportionality.toFixed(2)}% (${dispRating})</strong>
                <p style="margin-top: 5px; color: #2e7d32;">This measures deviation from perfect proportionality. 0% = perfect, higher = more disproportional.</p>
                ${results.allocationMethod ? `<p style="margin-top: 5px; color: #666;"><em>Using ${results.allocationMethod === 'dhondt' ? 'D\'Hondt' : 'Sainte-LaguÃ«'} method for seat allocation</em></p>` : ''}
            </div>`;
        }
        
        // Show threshold information if applicable
        if (results.threshold !== undefined && results.threshold > 0) {
            html += `<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                <strong>Electoral Threshold: ${results.threshold}%</strong>
                <p style="margin-top: 5px; color: #856404;">Parties must receive at least ${results.threshold}% of votes to win seats.</p>
            </div>`;
        }
        
        html += '<h3>Seat Allocation by Party</h3>';
        
        // Prepare comparison data for bar chart
        const comparisonData = [];
        
        results.results.forEach(r => {
            const seatPercentage = results.totalSeats > 0 ? (r.seats / results.totalSeats * 100) : 0;
            let statusBadge = '';
            if (r.belowThreshold) {
                statusBadge = '<span style="background: #e74c3c; color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.85em; margin-left: 8px;">Below Threshold</span>';
            }
            
            html += `
                <div class="result-item" style="border-left-color: ${r.color}; ${r.belowThreshold ? 'opacity: 0.6;' : ''}">
                    <div class="result-info">
                        <div class="result-name">${r.name}${statusBadge}</div>
                        <div class="result-stats">
                            ${formatNumber(r.votes)} votes (${r.percentage.toFixed(1)}%) â€¢ ${r.seats} seats (${seatPercentage.toFixed(1)}%)
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${seatPercentage}%">
                            ${r.seats} seats
                        </div>
                    </div>
                </div>
            `;
            
            // Collect data for charts
            votesChartData.push({
                label: r.name,
                value: r.votes,
                color: r.color
            });
            
            if (r.votes > 0 || r.seats > 0) {
                comparisonData.push({
                    label: r.name,
                    votePct: r.percentage,
                    seatPct: seatPercentage,
                    color: r.color
                });
            }
            
            if (r.seats > 0) {
                seatsChartData.push({
                    label: r.name,
                    value: r.seats,
                    color: r.color
                });
            }
        });
        
        // Store comparison data for later use
        results._comparisonData = comparisonData;
        
        if (results.candidateVotes) {
            html += '<h3 style="margin-top: 20px;">Top Candidates</h3>';
            results.candidateVotes.slice(0, 5).forEach(c => {
                html += `
                    <div class="result-item" style="border-left-color: ${c.color}">
                        <div class="result-info">
                            <div class="result-name">${c.name}</div>
                            <div class="result-stats">${c.party} â€¢ ${formatNumber(c.votes)} personal votes</div>
                        </div>
                    </div>
                `;
            });
        }
    } else if (results.type === 'mixed') {
        // Add charts section
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="comparisonChart" width="600" height="400"></canvas>';
        html += '</div>';
        
        // Show overhang seats warning for MMP
        if (results.overhangSeats && results.overhangSeats > 0) {
            html += `<div style="background: #ffe5e5; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #e74c3c;">
                <strong style="color: #c0392b;">âš ï¸ Overhang Seats: ${results.overhangSeats}</strong>
                <p style="margin-top: 5px; color: #a93226;">Parliament expanded from ${results.plannedSeats} to ${results.totalSeats} seats because some parties won more district seats than their proportional entitlement.</p>
            </div>`;
        }
        
        // Show disproportionality index if available
        if (results.disproportionality !== undefined) {
            const dispColor = results.disproportionality < 5 ? '#2ecc71' : results.disproportionality < 10 ? '#f39c12' : '#e74c3c';
            const dispRating = results.disproportionality < 5 ? 'Excellent' : results.disproportionality < 10 ? 'Moderate' : 'High';
            html += `<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid ${dispColor};">
                <strong style="color: ${dispColor};">ðŸ“Š Loosemore-Hanby Disproportionality Index: ${results.disproportionality.toFixed(2)}% (${dispRating})</strong>
                <p style="margin-top: 5px; color: #2e7d32;">Measures deviation from perfect proportionality. 0% = perfect, higher = more disproportional.</p>
                ${results.allocationMethod ? `<p style="margin-top: 5px; color: #666;"><em>Using ${results.allocationMethod === 'dhondt' ? 'D\'Hondt' : 'Sainte-LaguÃ«'} method for list seats</em></p>` : ''}
            </div>`;
        }
        
        // Show threshold information if applicable
        if (results.threshold !== undefined && results.threshold > 0) {
            html += `<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                <strong>Electoral Threshold: ${results.threshold}%</strong>
                <p style="margin-top: 5px; color: #856404;">Parties must receive at least ${results.threshold}% of party votes to win list seats.</p>
            </div>`;
        }
        
        html += '<h3>Seat Allocation by Party</h3>';
        
        // Prepare comparison data for bar chart
        const comparisonData = [];
        
        results.results.forEach(r => {
            const seatPercentage = results.totalSeats > 0 ? (r.seats / results.totalSeats * 100) : 0;
            let statusBadge = '';
            if (r.belowThreshold) {
                statusBadge = '<span style="background: #e74c3c; color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.85em; margin-left: 8px;">Below Threshold</span>';
            }
            if (r.hasOverhang) {
                statusBadge += ' <span style="background: #ff9800; color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.85em; margin-left: 8px;">Overhang</span>';
            }
            
            html += `
                <div class="result-item" style="border-left-color: ${r.color}; ${r.belowThreshold ? 'opacity: 0.6;' : ''}">
                    <div class="result-info">
                        <div class="result-name">${r.name}${statusBadge}</div>
                        <div class="result-stats">
                            ${formatNumber(r.votes)} votes (${r.percentage.toFixed(1)}%) â€¢ 
                            ${r.seats} total seats (${r.districtSeats} district + ${r.listSeats} list)
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${seatPercentage}%">
                            ${r.seats} seats
                        </div>
                    </div>
                </div>
            `;
            
            // Collect data for charts
            votesChartData.push({
                label: r.name,
                value: r.votes,
                color: r.color
            });
            
            if (r.votes > 0 || r.seats > 0) {
                comparisonData.push({
                    label: r.name,
                    votePct: r.percentage,
                    seatPct: seatPercentage,
                    color: r.color
                });
            }
            
            if (r.seats > 0) {
                seatsChartData.push({
                    label: r.name,
                    value: r.seats,
                    color: r.color
                });
            }
        });
        
        // Store comparison data for later use
        results._comparisonData = comparisonData;
    } else if (results.type === 'multi-winner') {
        // Add pie charts section
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="seatsChart" width="400" height="400"></canvas>';
        html += '</div>';
        
        html += '<h3>Elected Candidates</h3>';
        results.results.forEach(r => {
            html += `
                <div class="result-item" style="border-left-color: ${r.color}">
                    <div class="result-info">
                        <div class="result-name">
                            ${r.name}
                            ${r.elected ? '<span class="winner-badge">ELECTED</span>' : ''}
                        </div>
                        <div class="result-stats">
                            ${r.party} â€¢ ${formatNumber(r.votes)} votes â€¢ ${r.percentage.toFixed(1)}%
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${r.percentage}%">
                            ${r.percentage.toFixed(1)}%
                        </div>
                    </div>
                </div>
            `;
            
            // Collect data for charts
            votesChartData.push({
                label: r.name,
                value: r.votes,
                color: r.color
            });
            
            if (r.elected) {
                seatsChartData.push({
                    label: r.name,
                    value: 1,
                    color: r.color
                });
            }
        });
        if (results.quota) {
            html += `<p style="margin-top: 10px;"><strong>Quota needed:</strong> ${formatNumber(results.quota)} votes</p>`;
        }
        
        // Display round-by-round flow for IRV/STV
        if ((system === 'irv' || system === 'stv') && results.rounds && typeof displayRoundByRoundFlow === 'function') {
            html += displayRoundByRoundFlow(results.rounds, candidates);
        }
        
        // Display ideological spectrum
        if (typeof displayIdeologicalSpectrum === 'function' && candidates.length > 0) {
            html += displayIdeologicalSpectrum(candidates, results);
        }
    } else if (results.type === 'borda') {
        // Borda Count results
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="winnerChart" width="400" height="400"></canvas>';
        html += '</div>';
        
        html += `<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #4caf50;">
            <strong>ðŸ“Š Borda Count Method</strong>
            <p style="margin-top: 5px; color: #2e7d32;">${results.method || 'Points: n-1 for 1st place, n-2 for 2nd, etc.'}</p>
            <p style="margin-top: 5px; color: #666;">Total ballots: ${formatNumber(results.totalBallots)} â€¢ Total points awarded: ${formatNumber(Math.round(results.totalPoints))}</p>
        </div>`;
        
        html += '<h3>Results by Borda Points</h3>';
        results.results.forEach(r => {
            const pointPercentage = results.totalPoints > 0 ? (r.points / results.totalPoints * 100) : 0;
            
            html += `
                <div class="result-item" style="border-left-color: ${r.color}">
                    <div class="result-info">
                        <div class="result-name">
                            ${r.name}
                            ${r.winner ? '<span class="winner-badge">WINNER</span>' : ''}
                        </div>
                        <div class="result-stats">
                            ${r.party} â€¢ ${formatNumber(Math.round(r.points))} points â€¢ ${pointPercentage.toFixed(1)}%
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${pointPercentage}%">
                            ${formatNumber(Math.round(r.points))} pts
                        </div>
                    </div>
                </div>
            `;
            
            votesChartData.push({
                label: r.name,
                value: r.points,
                color: r.color
            });
            
            if (r.winner) {
                seatsChartData.push({
                    label: r.name + ' (Winner)',
                    value: 1,
                    color: r.color
                });
            }
        });
    } else if (results.type === 'condorcet') {
        // Condorcet results
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="winnerChart" width="400" height="400"></canvas>';
        html += '</div>';
        
        if (results.hasParadox) {
            html += `<div style="background: #ffe5e5; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #e74c3c;">
                <strong style="color: #c0392b;">âš ï¸ Condorcet Paradox Detected!</strong>
                <p style="margin-top: 5px; color: #a93226;">No candidate beats all others in head-to-head matchups. This demonstrates a voting cycle (A beats B, B beats C, C beats A).</p>
            </div>`;
        } else {
            html += `<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #4caf50;">
                <strong style="color: #2e7d32;">âœ… Condorcet Winner Found</strong>
                <p style="margin-top: 5px; color: #2e7d32;">This candidate beats every other candidate in head-to-head comparison.</p>
            </div>`;
        }
        
        html += '<h3>Pairwise Comparison Results</h3>';
        results.results.forEach(r => {
            html += `
                <div class="result-item" style="border-left-color: ${r.color}">
                    <div class="result-info">
                        <div class="result-name">
                            ${r.name}
                            ${r.is_condorcet_winner ? '<span class="winner-badge">CONDORCET WINNER</span>' : ''}
                        </div>
                        <div class="result-stats">
                            ${r.party} â€¢ Wins ${r.pairwise_wins} of ${candidates.length - 1} head-to-head matchups
                        </div>
                    </div>
                </div>
            `;
            
            votesChartData.push({
                label: r.name,
                value: r.pairwise_wins + 1,
                color: r.color
            });
            
            if (r.is_condorcet_winner) {
                seatsChartData.push({
                    label: r.name + ' (Winner)',
                    value: 1,
                    color: r.color
                });
            }
        });
    } else if (results.type === 'approval') {
        // Add pie charts section
        html += '<div class="charts-container">';
        html += '<canvas id="votesChart" width="400" height="400"></canvas>';
        html += '<canvas id="winnerChart" width="400" height="400"></canvas>';
        html += '</div>';
        
        html += '<h3>Results by Approvals</h3>';
        results.results.forEach(r => {
            html += `
                <div class="result-item" style="border-left-color: ${r.color}">
                    <div class="result-info">
                        <div class="result-name">
                            ${r.name}
                            ${r.winner ? '<span class="winner-badge">WINNER</span>' : ''}
                        </div>
                        <div class="result-stats">
                            ${r.party} â€¢ ${formatNumber(r.approvals)} approvals â€¢ ${r.percentage.toFixed(1)}%
                        </div>
                    </div>
                    <div class="result-bar">
                        <div class="result-bar-fill" style="width: ${r.percentage}%">
                            ${r.percentage.toFixed(1)}%
                        </div>
                    </div>
                </div>
            `;
            
            // Collect data for charts
            votesChartData.push({
                label: r.name,
                value: r.approvals,
                color: r.color
            });
            
            if (r.winner) {
                seatsChartData.push({
                    label: r.name + ' (Winner)',
                    value: 1,
                    color: r.color
                });
            }
        });
    }
    
    if (results.note) {
        html += `<p style="margin-top: 15px; color: #666; font-style: italic;">${results.note}</p>`;
    }
    
    resultsDiv.innerHTML = html;
    
    // Display Arrow's Theorem analysis
    const analysis = arrowAnalysis[system];
    let arrowHtml = `
        <h4>${analysis.title}</h4>
        <p style="margin-bottom: 15px;"><strong>Arrow's Impossibility Theorem</strong> states that no rank-order voting system can simultaneously satisfy all of the following fairness criteria when there are three or more alternatives:</p>
        <ul>
    `;
    
    analysis.violations.forEach(v => {
        arrowHtml += `<li>${v}</li>`;
    });
    
    arrowHtml += `
        </ul>
        <h4>Analysis for this System</h4>
        <p>${analysis.explanation}</p>
        <h4>Real-World Implications</h4>
        <p>${analysis.realWorld}</p>
    `;
    
    // Add Gibbard-Satterthwaite strategic voting analysis if available
    if (analysis.strategicVoting) {
        arrowHtml += `
            <h4 style="margin-top: 20px;">ðŸŽ¯ Strategic Voting (Gibbard-Satterthwaite Theorem)</h4>
            <p>${analysis.strategicVoting}</p>
        `;
    }
    
    arrowDiv.innerHTML = arrowHtml;
    
    // Draw charts after DOM is updated
    setTimeout(() => {
        const votesTitle = results.type === 'approval' ? 'Vote Distribution (Approvals)' : 'Vote Distribution';
        drawPieChart('votesChart', votesChartData, votesTitle);
        
        // For party and mixed systems, use comparison bar chart instead of pie chart
        if ((results.type === 'party' || results.type === 'mixed') && results._comparisonData) {
            drawComparisonBarChart('comparisonChart', results._comparisonData, 'Vote Share vs Seat Share');
        } else if (seatsChartData.length > 0) {
            let seatsTitle = 'Seat Distribution';
            if (results.type === 'candidate' || results.type === 'approval') {
                seatsTitle = 'Winner';
            } else if (results.type === 'multi-winner') {
                seatsTitle = 'Elected Candidates';
            }
            
            const seatsChartId = (results.type === 'candidate' || results.type === 'approval') ? 'winnerChart' : 'seatsChart';
            drawPieChart(seatsChartId, seatsChartData, seatsTitle);
        }
    }, 100);
    
    // Scroll to results
    resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

